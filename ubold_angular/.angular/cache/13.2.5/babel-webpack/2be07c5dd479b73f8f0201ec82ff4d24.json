{"ast":null,"code":"import { Directive, ElementRef, EventEmitter, Input, NgModule, NgZone, Output } from '@angular/core';\nimport { fromEvent, of } from 'rxjs';\nimport { filter, map, mergeMap, tap, throttleTime } from 'rxjs/operators';\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/services/ngx-ins-utils.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} selector\r\n * @param {?} scrollWindow\r\n * @param {?} defaultElement\r\n * @param {?} fromRoot\r\n * @return {?}\r\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n  /** @type {?} */\n  const hasWindow = window && !!window.document && window.document.documentElement;\n  /** @type {?} */\n\n  let container = hasWindow && scrollWindow ? window : defaultElement;\n\n  if (selector) {\n    /** @type {?} */\n    const containerIsString = selector && hasWindow && typeof selector === 'string';\n    container = containerIsString ? findElement(selector, defaultElement.nativeElement, fromRoot) : selector;\n\n    if (!container) {\n      throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n    }\n  }\n\n  return container;\n}\n/**\r\n * @param {?} selector\r\n * @param {?} customRoot\r\n * @param {?} fromRoot\r\n * @return {?}\r\n */\n\n\nfunction findElement(selector, customRoot, fromRoot) {\n  /** @type {?} */\n  const rootEl = fromRoot ? window.document : customRoot;\n  return rootEl.querySelector(selector);\n}\n/**\r\n * @param {?} prop\r\n * @return {?}\r\n */\n\n\nfunction inputPropChanged(prop) {\n  return prop && !prop.firstChange;\n}\n/**\r\n * @return {?}\r\n */\n\n\nfunction hasWindowDefined() {\n  return typeof window !== 'undefined';\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/services/axis-resolver.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/** @type {?} */\n\n\nconst VerticalProps = {\n  clientHeight: \"clientHeight\",\n  offsetHeight: \"offsetHeight\",\n  scrollHeight: \"scrollHeight\",\n  pageYOffset: \"pageYOffset\",\n  offsetTop: \"offsetTop\",\n  scrollTop: \"scrollTop\",\n  top: \"top\"\n};\n/** @type {?} */\n\nconst HorizontalProps = {\n  clientHeight: \"clientWidth\",\n  offsetHeight: \"offsetWidth\",\n  scrollHeight: \"scrollWidth\",\n  pageYOffset: \"pageXOffset\",\n  offsetTop: \"offsetLeft\",\n  scrollTop: \"scrollLeft\",\n  top: \"left\"\n};\n\nclass AxisResolver {\n  /**\r\n   * @param {?=} vertical\r\n   */\n  constructor(vertical = true) {\n    this.vertical = vertical;\n    this.propsMap = vertical ? VerticalProps : HorizontalProps;\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  clientHeightKey() {\n    return this.propsMap.clientHeight;\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  offsetHeightKey() {\n    return this.propsMap.offsetHeight;\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  scrollHeightKey() {\n    return this.propsMap.scrollHeight;\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  pageYOffsetKey() {\n    return this.propsMap.pageYOffset;\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  offsetTopKey() {\n    return this.propsMap.offsetTop;\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  scrollTopKey() {\n    return this.propsMap.scrollTop;\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  topKey() {\n    return this.propsMap.top;\n  }\n\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/services/event-trigger.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @record\r\n */\n\n/**\r\n * @record\r\n */\n\n/**\r\n * @record\r\n */\n\n/**\r\n * @record\r\n */\n\n/**\r\n * @param {?} alwaysCallback\r\n * @param {?} shouldFireScrollEvent\r\n * @param {?} isTriggeredCurrentTotal\r\n * @return {?}\r\n */\n\n\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n  if (alwaysCallback && shouldFireScrollEvent) {\n    return true;\n  }\n\n  if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n    return true;\n  }\n\n  return false;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/services/position-resolver.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} __0\r\n * @return {?}\r\n */\n\n\nfunction createResolver({\n  windowElement,\n  axis\n}) {\n  return createResolverWithContainer({\n    axis,\n    isWindow: isElementWindow(windowElement)\n  }, windowElement);\n}\n/**\r\n * @param {?} resolver\r\n * @param {?} windowElement\r\n * @return {?}\r\n */\n\n\nfunction createResolverWithContainer(resolver, windowElement) {\n  /** @type {?} */\n  const container = resolver.isWindow || windowElement && !windowElement.nativeElement ? windowElement : windowElement.nativeElement;\n  return Object.assign(Object.assign({}, resolver), {\n    container\n  });\n}\n/**\r\n * @param {?} windowElement\r\n * @return {?}\r\n */\n\n\nfunction isElementWindow(windowElement) {\n  /** @type {?} */\n  const isWindow = ['Window', 'global'].some(\n  /**\r\n  * @param {?} obj\r\n  * @return {?}\r\n  */\n  obj => Object.prototype.toString.call(windowElement).includes(obj));\n  return isWindow;\n}\n/**\r\n * @param {?} isContainerWindow\r\n * @param {?} windowElement\r\n * @return {?}\r\n */\n\n\nfunction getDocumentElement(isContainerWindow, windowElement) {\n  return isContainerWindow ? windowElement.document.documentElement : null;\n}\n/**\r\n * @param {?} element\r\n * @param {?} resolver\r\n * @return {?}\r\n */\n\n\nfunction calculatePoints(element, resolver) {\n  /** @type {?} */\n  const height = extractHeightForElement(resolver);\n  return resolver.isWindow ? calculatePointsForWindow(height, element, resolver) : calculatePointsForElement(height, element, resolver);\n}\n/**\r\n * @param {?} height\r\n * @param {?} element\r\n * @param {?} resolver\r\n * @return {?}\r\n */\n\n\nfunction calculatePointsForWindow(height, element, resolver) {\n  const {\n    axis,\n    container,\n    isWindow\n  } = resolver;\n  const {\n    offsetHeightKey,\n    clientHeightKey\n  } = extractHeightPropKeys(axis); // scrolled until now / current y point\n\n  /** @type {?} */\n\n  const scrolled = height + getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow); // total height / most bottom y point\n\n  /** @type {?} */\n\n  const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n  /** @type {?} */\n\n  const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) + nativeElementHeight;\n  return {\n    height,\n    scrolled,\n    totalToScroll,\n    isWindow\n  };\n}\n/**\r\n * @param {?} height\r\n * @param {?} element\r\n * @param {?} resolver\r\n * @return {?}\r\n */\n\n\nfunction calculatePointsForElement(height, element, resolver) {\n  const {\n    axis,\n    container\n  } = resolver; // perhaps use container.offsetTop instead of 'scrollTop'\n\n  /** @type {?} */\n\n  const scrolled = container[axis.scrollTopKey()];\n  /** @type {?} */\n\n  const totalToScroll = container[axis.scrollHeightKey()];\n  return {\n    height,\n    scrolled,\n    totalToScroll,\n    isWindow: false\n  };\n}\n/**\r\n * @param {?} axis\r\n * @return {?}\r\n */\n\n\nfunction extractHeightPropKeys(axis) {\n  return {\n    offsetHeightKey: axis.offsetHeightKey(),\n    clientHeightKey: axis.clientHeightKey()\n  };\n}\n/**\r\n * @param {?} __0\r\n * @return {?}\r\n */\n\n\nfunction extractHeightForElement({\n  container,\n  isWindow,\n  axis\n}) {\n  const {\n    offsetHeightKey,\n    clientHeightKey\n  } = extractHeightPropKeys(axis);\n  return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\n/**\r\n * @param {?} elem\r\n * @param {?} isWindow\r\n * @param {?} offsetHeightKey\r\n * @param {?} clientHeightKey\r\n * @return {?}\r\n */\n\n\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n  if (isNaN(elem[offsetHeightKey])) {\n    /** @type {?} */\n    const docElem = getDocumentElement(isWindow, elem);\n    return docElem ? docElem[clientHeightKey] : 0;\n  } else {\n    return elem[offsetHeightKey];\n  }\n}\n/**\r\n * @param {?} elem\r\n * @param {?} axis\r\n * @param {?} isWindow\r\n * @return {?}\r\n */\n\n\nfunction getElementOffsetTop(elem, axis, isWindow) {\n  /** @type {?} */\n  const topKey = axis.topKey(); // elem = elem.nativeElement;\n\n  if (!elem.getBoundingClientRect) {\n    // || elem.css('none')) {\n    return;\n  }\n\n  return elem.getBoundingClientRect()[topKey] + getElementPageYOffset(elem, axis, isWindow);\n}\n/**\r\n * @param {?} elem\r\n * @param {?} axis\r\n * @param {?} isWindow\r\n * @return {?}\r\n */\n\n\nfunction getElementPageYOffset(elem, axis, isWindow) {\n  /** @type {?} */\n  const pageYOffset = axis.pageYOffsetKey();\n  /** @type {?} */\n\n  const scrollTop = axis.scrollTopKey();\n  /** @type {?} */\n\n  const offsetTop = axis.offsetTopKey();\n\n  if (isNaN(window.pageYOffset)) {\n    return getDocumentElement(isWindow, elem)[scrollTop];\n  } else if (elem.ownerDocument) {\n    return elem.ownerDocument.defaultView[pageYOffset];\n  } else {\n    return elem[offsetTop];\n  }\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/services/scroll-resolver.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} container\r\n * @param {?} distance\r\n * @param {?} scrollingDown\r\n * @return {?}\r\n */\n\n\nfunction shouldFireScrollEvent(container, distance, scrollingDown) {\n  /** @type {?} */\n  let remaining;\n  /** @type {?} */\n\n  let containerBreakpoint;\n\n  if (container.totalToScroll <= 0) {\n    return false;\n  }\n  /** @type {?} */\n\n\n  const scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;\n\n  if (scrollingDown) {\n    remaining = (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n    containerBreakpoint = distance.down / 10;\n  } else {\n    /** @type {?} */\n    const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n    remaining = container.scrolled / totalHiddenContentHeight;\n    containerBreakpoint = distance.up / 10;\n  }\n  /** @type {?} */\n\n\n  const shouldFireEvent = remaining <= containerBreakpoint;\n  return shouldFireEvent;\n}\n/**\r\n * @param {?} lastScrollPosition\r\n * @param {?} container\r\n * @return {?}\r\n */\n\n\nfunction isScrollingDownwards(lastScrollPosition, container) {\n  return lastScrollPosition < container.scrolled;\n}\n/**\r\n * @param {?} lastScrollPosition\r\n * @param {?} container\r\n * @param {?} distance\r\n * @return {?}\r\n */\n\n\nfunction getScrollStats(lastScrollPosition, container, distance) {\n  /** @type {?} */\n  const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n  return {\n    fire: shouldFireScrollEvent(container, distance, scrollDown),\n    scrollDown\n  };\n}\n/**\r\n * @param {?} position\r\n * @param {?} scrollState\r\n * @return {?}\r\n */\n\n/**\r\n * @param {?} totalToScroll\r\n * @param {?} scrollState\r\n * @return {?}\r\n */\n\n/**\r\n * @param {?} scrollState\r\n * @return {?}\r\n */\n\n/**\r\n * @param {?} scroll\r\n * @param {?} scrollState\r\n * @param {?} triggered\r\n * @param {?} isScrollingDown\r\n * @return {?}\r\n */\n\n/**\r\n * @param {?} totalToScroll\r\n * @param {?} scrollState\r\n * @param {?} isScrollingDown\r\n * @return {?}\r\n */\n\n/**\r\n * @param {?} scrollState\r\n * @param {?} scrolledUntilNow\r\n * @param {?} totalToScroll\r\n * @return {?}\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/services/scroll-state.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nclass ScrollState {\n  /**\r\n   * @param {?} __0\r\n   */\n  constructor({\n    totalToScroll\n  }) {\n    this.lastScrollPosition = 0;\n    this.lastTotalToScroll = 0;\n    this.totalToScroll = 0;\n    this.triggered = {\n      down: 0,\n      up: 0\n    };\n    this.totalToScroll = totalToScroll;\n  }\n  /**\r\n   * @param {?} position\r\n   * @return {?}\r\n   */\n\n\n  updateScrollPosition(position) {\n    return this.lastScrollPosition = position;\n  }\n  /**\r\n   * @param {?} totalToScroll\r\n   * @return {?}\r\n   */\n\n\n  updateTotalToScroll(totalToScroll) {\n    if (this.lastTotalToScroll !== totalToScroll) {\n      this.lastTotalToScroll = this.totalToScroll;\n      this.totalToScroll = totalToScroll;\n    }\n  }\n  /**\r\n   * @param {?} scrolledUntilNow\r\n   * @param {?} totalToScroll\r\n   * @return {?}\r\n   */\n\n\n  updateScroll(scrolledUntilNow, totalToScroll) {\n    this.updateScrollPosition(scrolledUntilNow);\n    this.updateTotalToScroll(totalToScroll);\n  }\n  /**\r\n   * @param {?} scroll\r\n   * @param {?} isScrollingDown\r\n   * @return {?}\r\n   */\n\n\n  updateTriggeredFlag(scroll, isScrollingDown) {\n    if (isScrollingDown) {\n      this.triggered.down = scroll;\n    } else {\n      this.triggered.up = scroll;\n    }\n  }\n  /**\r\n   * @param {?} totalToScroll\r\n   * @param {?} isScrollingDown\r\n   * @return {?}\r\n   */\n\n\n  isTriggeredScroll(totalToScroll, isScrollingDown) {\n    return isScrollingDown ? this.triggered.down === totalToScroll : this.triggered.up === totalToScroll;\n  }\n\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/services/scroll-register.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} config\r\n * @return {?}\r\n */\n\n\nfunction createScroller(config) {\n  const {\n    scrollContainer,\n    scrollWindow,\n    element,\n    fromRoot\n  } = config;\n  /** @type {?} */\n\n  const resolver = createResolver({\n    axis: new AxisResolver(!config.horizontal),\n    windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n  });\n  /** @type {?} */\n\n  const scrollState = new ScrollState({\n    totalToScroll: calculatePoints(element, resolver)\n  });\n  /** @type {?} */\n\n  const options = {\n    container: resolver.container,\n    throttle: config.throttle\n  };\n  /** @type {?} */\n\n  const distance = {\n    up: config.upDistance,\n    down: config.downDistance\n  };\n  return attachScrollEvent(options).pipe(mergeMap(\n  /**\r\n  * @return {?}\r\n  */\n  () => of(calculatePoints(element, resolver))), map(\n  /**\r\n  * @param {?} positionStats\r\n  * @return {?}\r\n  */\n  positionStats => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance)), tap(\n  /**\r\n  * @param {?} __0\r\n  * @return {?}\r\n  */\n  ({\n    stats\n  }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll)), filter(\n  /**\r\n  * @param {?} __0\r\n  * @return {?}\r\n  */\n  ({\n    fire,\n    scrollDown,\n    stats: {\n      totalToScroll\n    }\n  }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown))), tap(\n  /**\r\n  * @param {?} __0\r\n  * @return {?}\r\n  */\n  ({\n    scrollDown,\n    stats: {\n      totalToScroll\n    }\n  }) => {\n    scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n  }), map(toInfiniteScrollAction));\n}\n/**\r\n * @param {?} options\r\n * @return {?}\r\n */\n\n\nfunction attachScrollEvent(options) {\n  /** @type {?} */\n  let obs = fromEvent(options.container, 'scroll'); // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n  // Let's avoid calling the function unless needed.\n  // Replacing with throttleTime seems to solve the problem\n  // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n\n  if (options.throttle) {\n    obs = obs.pipe(throttleTime(options.throttle));\n  }\n\n  return obs;\n}\n/**\r\n * @param {?} lastScrollPosition\r\n * @param {?} stats\r\n * @param {?} distance\r\n * @return {?}\r\n */\n\n\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n  const {\n    scrollDown,\n    fire\n  } = getScrollStats(lastScrollPosition, stats, distance);\n  return {\n    scrollDown,\n    fire,\n    stats\n  };\n}\n/** @type {?} */\n\n\nconst InfiniteScrollActions = {\n  DOWN: '[NGX_ISE] DOWN',\n  UP: '[NGX_ISE] UP'\n};\n/**\r\n * @param {?} response\r\n * @return {?}\r\n */\n\nfunction toInfiniteScrollAction(response) {\n  const {\n    scrollDown,\n    stats: {\n      scrolled: currentScrollPosition\n    }\n  } = response;\n  return {\n    type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n    payload: {\n      currentScrollPosition\n    }\n  };\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/modules/infinite-scroll.directive.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nlet InfiniteScrollDirective = /*#__PURE__*/(() => {\n  class InfiniteScrollDirective {\n    /**\r\n     * @param {?} element\r\n     * @param {?} zone\r\n     */\n    constructor(element, zone) {\n      this.element = element;\n      this.zone = zone;\n      this.scrolled = new EventEmitter();\n      this.scrolledUp = new EventEmitter();\n      this.infiniteScrollDistance = 2;\n      this.infiniteScrollUpDistance = 1.5;\n      this.infiniteScrollThrottle = 150;\n      this.infiniteScrollDisabled = false;\n      this.infiniteScrollContainer = null;\n      this.scrollWindow = true;\n      this.immediateCheck = false;\n      this.horizontal = false;\n      this.alwaysCallback = false;\n      this.fromRoot = false;\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngAfterViewInit() {\n      if (!this.infiniteScrollDisabled) {\n        this.setup();\n      }\n    }\n    /**\r\n     * @param {?} __0\r\n     * @return {?}\r\n     */\n\n\n    ngOnChanges({\n      infiniteScrollContainer,\n      infiniteScrollDisabled,\n      infiniteScrollDistance\n    }) {\n      /** @type {?} */\n      const containerChanged = inputPropChanged(infiniteScrollContainer);\n      /** @type {?} */\n\n      const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n      /** @type {?} */\n\n      const distanceChanged = inputPropChanged(infiniteScrollDistance);\n      /** @type {?} */\n\n      const shouldSetup = !disabledChanged && !this.infiniteScrollDisabled || disabledChanged && !infiniteScrollDisabled.currentValue || distanceChanged;\n\n      if (containerChanged || disabledChanged || distanceChanged) {\n        this.destroyScroller();\n\n        if (shouldSetup) {\n          this.setup();\n        }\n      }\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    setup() {\n      if (hasWindowDefined()) {\n        this.zone.runOutsideAngular(\n        /**\r\n        * @return {?}\r\n        */\n        () => {\n          this.disposeScroller = createScroller({\n            fromRoot: this.fromRoot,\n            alwaysCallback: this.alwaysCallback,\n            disable: this.infiniteScrollDisabled,\n            downDistance: this.infiniteScrollDistance,\n            element: this.element,\n            horizontal: this.horizontal,\n            scrollContainer: this.infiniteScrollContainer,\n            scrollWindow: this.scrollWindow,\n            throttle: this.infiniteScrollThrottle,\n            upDistance: this.infiniteScrollUpDistance\n          }).subscribe(\n          /**\r\n          * @param {?} payload\r\n          * @return {?}\r\n          */\n          payload => this.zone.run(\n          /**\r\n          * @return {?}\r\n          */\n          () => this.handleOnScroll(payload)));\n        });\n      }\n    }\n    /**\r\n     * @param {?} __0\r\n     * @return {?}\r\n     */\n\n\n    handleOnScroll({\n      type,\n      payload\n    }) {\n      switch (type) {\n        case InfiniteScrollActions.DOWN:\n          return this.scrolled.emit(payload);\n\n        case InfiniteScrollActions.UP:\n          return this.scrolledUp.emit(payload);\n\n        default:\n          return;\n      }\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngOnDestroy() {\n      this.destroyScroller();\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    destroyScroller() {\n      if (this.disposeScroller) {\n        this.disposeScroller.unsubscribe();\n      }\n    }\n\n  }\n\n  InfiniteScrollDirective.ɵfac = function InfiniteScrollDirective_Factory(t) {\n    return new (t || InfiniteScrollDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  InfiniteScrollDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: InfiniteScrollDirective,\n    selectors: [[\"\", \"infiniteScroll\", \"\"], [\"\", \"infinite-scroll\", \"\"], [\"\", \"data-infinite-scroll\", \"\"]],\n    inputs: {\n      infiniteScrollDistance: \"infiniteScrollDistance\",\n      infiniteScrollUpDistance: \"infiniteScrollUpDistance\",\n      infiniteScrollThrottle: \"infiniteScrollThrottle\",\n      infiniteScrollDisabled: \"infiniteScrollDisabled\",\n      infiniteScrollContainer: \"infiniteScrollContainer\",\n      scrollWindow: \"scrollWindow\",\n      immediateCheck: \"immediateCheck\",\n      horizontal: \"horizontal\",\n      alwaysCallback: \"alwaysCallback\",\n      fromRoot: \"fromRoot\"\n    },\n    outputs: {\n      scrolled: \"scrolled\",\n      scrolledUp: \"scrolledUp\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return InfiniteScrollDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/modules/ngx-infinite-scroll.module.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nlet InfiniteScrollModule = /*#__PURE__*/(() => {\n  class InfiniteScrollModule {}\n\n  InfiniteScrollModule.ɵfac = function InfiniteScrollModule_Factory(t) {\n    return new (t || InfiniteScrollModule)();\n  };\n\n  InfiniteScrollModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: InfiniteScrollModule\n  });\n  InfiniteScrollModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [],\n    imports: [[]]\n  });\n  return InfiniteScrollModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(InfiniteScrollModule, {\n    declarations: [InfiniteScrollDirective],\n    exports: [InfiniteScrollDirective]\n  });\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/ngx-infinite-scroll.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: public-api.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Angular library starter.\r\n * Build an Angular library compatible with AoT compilation & Tree shaking.\r\n * Written by Roberto Simonetti.\r\n * MIT license.\r\n * https://github.com/robisim74/angular-library-starter\r\n */\n\n/**\r\n * Entry point for all public APIs of the package.\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: ngx-infinite-scroll.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { InfiniteScrollDirective, InfiniteScrollModule }; //# sourceMappingURL=ngx-infinite-scroll.js.map","map":null,"metadata":{},"sourceType":"module"}